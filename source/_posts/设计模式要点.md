---
title: 设计模式要点
date: 2023-03-02 13:01:27
tags:
---

设计模式复习中一些记忆要点

<!--more-->

## SOLID原则

| 首字母 |                            指代                            |                             概念                             |
| :----: | :--------------------------------------------------------: | :----------------------------------------------------------: |
|   S    | [单一功能原则](https://zh.wikipedia.org/wiki/单一功能原则) | 认为“**[对象](https://zh.wikipedia.org/wiki/对象_(计算机科学))应该仅具有一种单一功能**”的概念。 |
|   O    |     [开闭原则](https://zh.wikipedia.org/wiki/开闭原则)     | 认为“**软件应该是对于扩展开放的，但是对于修改封闭的**”的概念。 |
|   L    | [里氏替换原则](https://zh.wikipedia.org/wiki/里氏替换原则) | 认为“**程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的**”的概念。 |
|   I    | [接口隔离原则](https://zh.wikipedia.org/wiki/接口隔离原则) | 认为“**多个特定客户端接口要好于一个宽泛用途的接口**”[[5\]](https://zh.wikipedia.org/wiki/SOLID_(面向对象设计)#cite_note-martin-design-principles-5) 的概念。 |
|   D    | [依赖反转原则](https://zh.wikipedia.org/wiki/依赖反转原则) | 认为一个方法应该遵从“**依赖于抽象而不是一个实例**”[[5\]](https://zh.wikipedia.org/wiki/SOLID_(面向对象设计)#cite_note-martin-design-principles-5) 的概念。 [依赖注入](https://zh.wikipedia.org/wiki/依赖注入)是该原则的一种实现方式。 |

## 基本要素

设计模式的基本要素有**模式名称**、**问题**、**解决方案**和**效果**

## 创建性模式

用来创建对象的模式，抽象了实例化过程 

- 工厂模式：父类负责定义创建对象的公共接口，而子类则负责生成具体对象，将类的实例化操作延迟到子类中完成

- 抽象工厂模式：为一个产品族提供统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列 ，创建一个具体的工厂类

- 单例模式：一个类有且仅有一个实例，提供一个全局访问点

- 建造者模式：将复杂对象创建与表示分离，同样的创建过程可创建不同的表示。允许用户通过指定复杂对象类型和内容来创建对象，用户无需知道对象内部的具体构建细节

- 原型模式：通过“复制”一个已存在的实例来返回新的实例（不新建实例）。被复制的实例就是“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据

## 结构型模式

结构型模式关注如何将现有类或对象组织在一起形成更加强大的结构，可分为两种：

- 类结构型模式：关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系
- 对象结构型模式：关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。更符合“合成复用原则”

具体的设计模式

- 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
- 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
- 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
- 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
- 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
- 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
- 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性

## 行为型模式

行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。

**模板方法（Template Method）模式**：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

**策略（Strategy）模式**：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。

**命令（Command）模式**：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。

**职责链（Chain of Responsibility）模式**：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。

**状态（State）模式**：允许一个对象在其内部状态发生改变时改变其行为能力。

**观察者（Observer）模式**：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

**中介者（Mediator）模式**：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。

**迭代器（Iterator）模式**：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

**访问者（Visitor）模式**：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。

**备忘录（Memento）模式**：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。

**解释器（Interpreter）模式**：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

