{"posts":[{"title":"使用hexo的记录","text":"设置展开 1&lt;!--more--&gt; more上面的内容是展示的，下面的内容是不展示的","link":"/blog/2023/03/05/%E4%BD%BF%E7%94%A8hexo%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"title":"设计模式复习","text":"SOLID原则 首字母 指代 概念 S 单一功能原则 认为“**对象应该仅具有一种单一功能**”的概念。 O 开闭原则 认为“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。 L 里氏替换原则 认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。 I 接口隔离原则 认为“多个特定客户端接口要好于一个宽泛用途的接口”[5] 的概念。 D 依赖反转原则 认为一个方法应该遵从“依赖于抽象而不是一个实例”[5] 的概念。 依赖注入是该原则的一种实现方式。 设计模式的基本要素有模式名称、问题、解决方案和效果 创建性模式工厂方法模式（与简单工厂不同）意图工厂方法模式是一种创建型设计模式， 其在父类（Factory）中提供一个创建对象的方法， 允许子类(ConcreteFactory)决定实例化对象的类型。 结构 抽象工厂模式意图抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。 结构 生成器模式意图将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示 生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。 结构 单例模式意图单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。 结构 原型模式意图原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。 结构 原型 （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。 具体原型 （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。 客户端 （Client） 可以复制实现了原型接口的任何对象。 结构性模式适配器模式意图适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。 结构 对象适配器 类适配器 区别 类适配器的重点在于类，是通过构造一个继承Adaptee类来实现适配器的功能； 对象适配器的重点在于对象，是通过在直接包含Adaptee类来实现的，当需要调用特殊功能的时候直接使用Adapter中包含的那个Adaptee对象来调用特殊功能的方法即可。 桥接模式意图桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。（桥接模式的作用就是将前端部分与后端部分分离，使它可以独立的变化） 在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。 一般来说， 你可以在两个独立方向上扩展这种应用： 开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置） 支持多个不同的 API （例如， 能够在 Windows、 Linux 和 macOS 上运行该程序）。 结构 组合模式意图组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。 结构 组件 （Component） 接口描述了树中简单项目和复杂项目所共有的操作。 叶节点 （Leaf） 是树的基本结构， 它不包含子项目。 一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。 容器 （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。 容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。 装饰模式意图装饰模式可以在不需要创造更多子类的情况下，以动态、透明的方式将对象的功能加以扩展。 结构 外观模式（Facade）意图提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用 结构 享元模式（flyweight）意图避免大量拥有相同内容的小类的开销，使大家共享一个类(元类) 结构 代理模式（proxy）意图出发点到目的地的直接交互比较困难，或者不方便，需要有一个中间层提供一种服务以控制、方便这种交互 结构 行为型模式行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 责任链模式意图解除请求发送者和接收者之间耦合，使多个对象都有机会处理一个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它 结构 降低了系统耦合性，请求的发送者完全不必知道该请求会被哪个对象处理，极大地降低了系统的耦合性 消息传递会出现消息得不到处理的可能 命令模式（command）意图将一个请求封装为一个对象，客户端用不同参数对应不同请求 结构 解释器模式（interpreter）意图给定一个语言，定义其文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子 结构 应用：XMLParser 迭代器模式（iterator）意图迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。 结构 中介者模式意图中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。 结构 备忘录模式（快照、Snapshot、Memento）意图备忘录模式是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。 结构 观察者模式（Observer）意图定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 结构 状态模式意图让对象在其内部状态改变时，其行为也随之改变 结构 策略模式意图定义一系列算法进行封装，并使其可相互替换。策略模式使得算法可独立于使用它的客户而变化 结构 模板方法模式（Template）意图定义操作中算法的骨架，将一些步骤的执行延迟到其子类中，子类不需要改变算法结构即可重定义算法的某些步骤 结构 访问者模式意图作用于某个对象群中各个对象的操作。可在不改变这些对象本身的情况下，定义作用于这些对象的新操作 访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。 结构","link":"/blog/2023/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0/"},{"title":"设计模式要点","text":"设计模式复习中一些记忆要点 SOLID原则 首字母 指代 概念 S 单一功能原则 认为“**对象应该仅具有一种单一功能**”的概念。 O 开闭原则 认为“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。 L 里氏替换原则 认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。 I 接口隔离原则 认为“多个特定客户端接口要好于一个宽泛用途的接口”[5] 的概念。 D 依赖反转原则 认为一个方法应该遵从“依赖于抽象而不是一个实例”[5] 的概念。 依赖注入是该原则的一种实现方式。 基本要素设计模式的基本要素有模式名称、问题、解决方案和效果 创建性模式用来创建对象的模式，抽象了实例化过程 工厂模式：父类负责定义创建对象的公共接口，而子类则负责生成具体对象，将类的实例化操作延迟到子类中完成 抽象工厂模式：为一个产品族提供统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列 ，创建一个具体的工厂类 单例模式：一个类有且仅有一个实例，提供一个全局访问点 建造者模式：将复杂对象创建与表示分离，同样的创建过程可创建不同的表示。允许用户通过指定复杂对象类型和内容来创建对象，用户无需知道对象内部的具体构建细节 原型模式：通过“复制”一个已存在的实例来返回新的实例（不新建实例）。被复制的实例就是“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据 结构型模式结构型模式关注如何将现有类或对象组织在一起形成更加强大的结构，可分为两种： 类结构型模式：关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系 对象结构型模式：关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。更符合“合成复用原则” 具体的设计模式 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性 行为型模式行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。","link":"/blog/2023/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A6%81%E7%82%B9/"}],"tags":[],"categories":[],"pages":[]}